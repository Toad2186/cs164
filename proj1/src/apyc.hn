/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors:
 * Toan Vuong
 * Eugene Huang
 * Dennis Rong
*/

/*
 * LIST OF CONFLICTS
 * A list of conflicts encountered that we solved using GLR. The compiler will
 * still complain, but these conflicts should be ignored. Other conflicts
 * should be added to this list if solved with GLR. Otherwise fix it
 * so the compiler doesn't complain anymore!
 * -4x conflicts in target


*/


%define semantic_tree_type "AST"

%{
  #include <string>
  #include <algorithm>
  #include <stack>
  #include "apyc.h"
  #include "ast.h"

  using namespace std;

  static AST_Ptr theTree;

/* Utilities */
//-----------------------------------------------------------------------------
//  Generalizable make functions
//-----------------------------------------------------------------------------

/*
 * Given a list of operands and OP, make a tree:
 * (OP, N, Expr(0), Id(1), Expr(2))
 * Where Expr(i) is the direct node from the list of operands
 * and Id(1) is the node returned by make_id of the first operand
*/
static AST_Ptr make_expr_id_expr(const List_Ptr &operands, int op); 

/*
 * Given a list of operands and OP, make a tree:
 * (OP, N, Expr(0), Expr(1))
 * Where Expr(i) is the direct node from the list of operands
*/
static AST_Ptr make_expr_expr(const List_Ptr &operands, int op);

//-----------------------------------------------------------------------------
//  Specific make functions that may use those above internally.
//  At least one of these per entry in the AST table in proj1 handout
//-----------------------------------------------------------------------------

/** Return a new unop node corresponding to OPERANDS, which is the list of
*  right-hand-side semantic values of a unop production (consisting of a
*  token for the operator, followed by the AST for the operand). */
static AST_Ptr make_unop (const List_Ptr& operands);

/** Return a new binop node corresponding to OPERANDS, which is the list of
*  right-hand-side semantic values of a binop production (consisting of an
*  AST for the first operand, a token for the operator, and an AST for the
*  second operand). */
static AST_Ptr make_binop(const List_Ptr &operands);

/*
 * Makes a left_compare node
*/
static AST_Ptr make_left_compare(const List_Ptr &operands);

/*
 * Makes  acompare node
*/
static AST_Ptr make_compare(const List_Ptr &operands);

/*
* Makes an id from the first operand in OPERANDS.
*/
static AST_Ptr make_id (const List_Ptr& operands);

/** Return a new ID node, where the text of the identifier is given by
*  TOKEN. */
static AST_Ptr make_id (AST_Ptr& token);

/*
 * Makes an id token from text
*/
static AST_Ptr make_id (const char *text, const char*loc);

/*
 * Makes an if_expr node.
 * Expects a list of three operands: condition, expr1, expr2
*/
static AST_Ptr make_if_expr(const List_Ptr &operands);

/*
 * Makes an assignment
*/
static AST_Ptr make_assign(const List_Ptr &operands);

//-----------------------------------------------------------------------------
// HELPER FUNCTIONS 
//-----------------------------------------------------------------------------
static string invalid_keywords[14] = {"as", "assert", "del", "except", "exec", "finally", "future", "global", "import", "lambda", "raise", "try", "with", "yield"};
static string keywords[18] = {"and", "break", "class", "continue", "def", "elif", "else", "for", "from", "if", "in", "is", "not", "or", "pass", "print", "return", "while"};

static stack<int> indent_stack;
static int current_indent_length = 0;
static void check_identifier(const char *text);
static int indent_size(const char *indent);

static int indent(const char *indent);

%}

/* Precedence and associativity rules */
%left "or"
%left "and"
%left "not"
%left "<" ">" "==" ">=" "<=" "!=" "is" "in"
%left "+" "-"
%left "%" "*" "/" "//"
%left UNOP
%right "**"

%debug
%glr-parser
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a consant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token ID

%token PRINTLN "@println"
%token EMPTY 
%token EXPR_LIST "@expr_list"
%token MODULE "@module"
%token BINOP "@binop"
%token UNOP "@unop"
%token INT_LITERAL "@int_literal"
%token DICT_DISPLAY "@dict_display"
%token COMPARE "@compare"
%token LEFT_COMPARE "@left_compare"
%token ASSIGN "@assign"
%token IF_EXPR "@if_expr"
%token DIVDIV "//"
%token POW "**"

%token STRING
%token STRING_LITERAL

%token INDENT
%token DEDENT

/* Keywords */
%token AND "and"
%token BREAK "break"
%token CLASS "class"
%token CONTINUE "continue"
%token DEF "def"
%token ELIF "elif"
%token ELSE "else"
%token FOR "for"
%token FROM "from"
%token IF "if"
%token IN "in"
%token IS "is"
%token NOT "not"
%token OR "or"
%token PASS "pass"
%token PRINT "print"
%token RETURN "return"
%token WHILE "while"

%%

/************** LEXICAL RULES ********************/
/*
 * All Caps for clarity
 * No unicode, long ints, imaginary, float, or unallowed keywords
 */

/*
 * Predefined: _ANY, _UPPER, _LOWER, _CONTROL, _EOL, _BOL
 */

_BLANK : ' ' | '\t' ;

_DIGIT : '0' .. '9' ;
_NONZERODIGIT : '1' .. '9' ;
_HEXDIGIT : _DIGIT | 'a' .. 'f' | 'A' .. 'F' ;
_OCTDIGIT : '0' .. '7' ;

_DECIMALINTEGER : _NONZERODIGIT _DIGIT* | "0" ;
_OCTINTEGER : "0" _OCTDIGIT+ ;
_HEXINTEGER: "0" ( "x" | "X" ) _HEXDIGIT+ ;
_INTEGER : _DECIMALINTEGER | _OCTINTEGER | _HEXINTEGER ;
_EXPONENT : ( "e" | "E" ) ( "+" | "-")? _DIGIT+ ;

_LOWER : 'a' .. 'z' ;
_UPPER : 'A' .. 'Z' ;
_LETTER : _UPPER | _LOWER ;

_RAWSTRINGPREFIX : 'r' | 'R' ;
_RAWESCAPESEQ : '\\' _ANY ;
_ESCAPESEQ : _RAWESCAPESEQ | ( '\\' _OCTDIGIT _OCTDIGIT? _OCTDIGIT? ) ;

/* Careful. Horn rules can only do set subtraction on its own lexical rule */
_NO_SINGLEQUOTE : _ANY - ('\'' | '\n') ;
_NO_DOUBLEQUOTE : _ANY - ('"' | '\n') ;
_NO_SLASH : _ANY - ('\\' | '\n') ;

_SHORTSTRINGITEM1 : _NO_SINGLEQUOTE | _ESCAPESEQ ;
_SHORTSTRINGITEM2 : _NO_DOUBLEQUOTE | _ESCAPESEQ ;
_LONGSTRINGITEM : _NO_SLASH | _ESCAPESEQ ;

_RAWSHORTSTRINGITEM1 : _NO_SINGLEQUOTE | _RAWESCAPESEQ ;
_RAWSHORTSTRINGITEM2 : _NO_DOUBLEQUOTE | _RAWESCAPESEQ ;
_RAWLONGSTRINGITEM : _NO_SLASH | _RAWESCAPESEQ ;

_SHORTSTRING : '\'' _SHORTSTRINGITEM1* '\''
    | '"' _SHORTSTRINGITEM2* '"'
    ;
_RAWSHORTSTRING : '\'' _RAWSHORTSTRINGITEM1* '\''
    | '"' _RAWSHORTSTRINGITEM2* '"'
    ;

/* TODO: Helper function find 'shortest sequence of longitems' */
_LONGSTRING : "'''" ( _LONGSTRINGITEM* ("'" | "''")? )* "'''"
    | "\"\"\"" ( _LONGSTRINGITEM* ("\"" | "\"\"")? )* "\"\"\""
    ;
_RAWLONGSTRING : "'''" ( _RAWLONGSTRINGITEM* ("'" | "''")? )* "'''"
    | "\"\"\"" ( _RAWLONGSTRINGITEM* ("\"" | "\"\"")? )* "\"\"\""
    ;

_STRINGLITERALPIECE : ( _SHORTSTRING | _LONGSTRING )
    | _RAWSTRINGPREFIX ( _RAWSHORTSTRING | _RAWLONGSTRING )
    ;

/* TODO: fix */
/* Unsupported Keywords. Error */
/* *: ( "as" | "assert" | "del" | "except" | "exec" | "finally" | "future" | "global"
 *   | "import" | "lambda" | "raise" | "try" | "with" | "yield" ) ;
 */

_NO_NEWLINE : _ANY - '\n' ;
_COMMENT : '#' _NO_NEWLINE* ;

/* HANDLE INDENTATION */
* : (' ' | '\t' | '\r')+ ;
* : _BOL _BLANK* '\n' %prefer
    | _BOL _BLANK* _COMMENT '\n' %prefer
    ;
* : _BOL _BLANK+ %prefer
    {
      YYSET_TOKEN(indent($TEXT));
    }
    ;

/* Exclude keywords. */
IDENTIFIER : ( _LETTER | "_" ) ( _LETTER | _DIGIT | "_" )*
    {
      check_identifier($TEXT);
    }
    ;

/* RULES FOR AST */
INT_LITERAL : _INTEGER ;
STRING_LITERAL : _STRINGLITERALPIECE+ ;

RAWSTRING : _RAWSTRINGPREFIX (_RAWSHORTSTRING | _RAWLONGSTRING) ;


/**************** GRAMMAR RULES ********************/

/*
 * Start program
*/
program : stmt_list   { theTree = $^(MODULE, $*); $$ = NULL; }
        | /* empty */ { theTree = $^(MODULE); $$ = NULL; }
        ;

/*
 * Main statements and expressions
*/
stmt_list : stmt ('\n'! stmt)+
          ;

expression_list : expression (","! expression)* { $$ = $^(EXPR_LIST, $*); }
                ;

expression : conditional_expr 
           ;

enclosure : parenth_form
          | list_display
          | dict_display
          ;

parenth_form : "(" expression_list ")"
             ;

/*
 * Basic units
*/
identifier : IDENTIFIER
           ;
atom : identifier
     | literal
     | enclosure
     ;

primary : atom                       
        | attributeref
        | subscription
        ;

literal : STRING_LITERAL
        | INT_LITERAL
        ;

//-----------------------------------------------------------------------------
//  Lists
//-----------------------------------------------------------------------------
list_display : "[" expression_list "]"
             ;
//-----------------------------------------------------------------------------
//  Dictionaries
//-----------------------------------------------------------------------------
dict_display : "{" key_datum_list "}"
             | "{" "}"
             ;

key_datum_list : key_datum (","! key_datum)+ ","!?
               ;

key_datum : expression ":" expression
          ;

attributeref : primary "." identifier
             ;

subscription : primary "[" expression_list "]"
             ;

//-----------------------------------------------------------------------------
//  Slicing
//-----------------------------------------------------------------------------
slicing : simple_slicing
        ;

simple_slicing : primary "[" short_slice "]"
               ;

short_slice : lower_bound ":" upper_bound
            ;

lower_bound : expression
            | /* empty */
            ;

upper_bound : lower_bound
            ;

/*
 * Primitive operators + - * ** / //
*/
power : primary                     
      | primary "**" u_expr         { $$ = make_binop($*); }
      ;

u_expr : power                     
       | "-" u_expr                 { $$ = make_unop($*); }
       | "+" u_expr                 { $$ = make_unop($*); }
       ;

m_expr : u_expr                    
       | m_expr "*" u_expr          { $$ = make_binop($*); }
       | m_expr "//" u_expr         { $$ = make_binop($*); }
       | m_expr "/" u_expr          { $$ = make_binop($*); }
       | m_expr "%" u_expr          { $$ = make_binop($*); }
       ;

a_expr : m_expr                 
       | a_expr "+" m_expr          { $$ = make_binop($*); }
       | a_expr "-" m_expr          { $$ = make_binop($*); }
       ;

/*
 * Comparisons. Need to differentiate between compare and left_compare
*/
comparison_expr : a_expr comp_operator a_expr                   { $$ = make_compare($*); }
                | a_expr comp_operator comparison_expr          { $$ = make_left_compare($*); }
                ;

comp_operator : "<"
              | ">"
              | "=="
              | ">="
              | "<="
              | "!="
              | "is"
// TODO: Not pass in a constant isnot and notin. 
              | L="is not"              { $$ = make_id("isnot", $L.loc()); } 
              | "in"
              | L="not in"              { $$ = make_id("notin", $L.loc()); }
              ;

/*
 * Boolean operators
*/
conditional_expr : or_test
                 | or_test "if"! or_test "else"! expression 
                        { $$ = make_if_expr($*); }
                 ;

or_test : and_test
        | or_test "or" and_test
        ;
and_test : not_test
         | and_test "and" not_test
         ;
not_test : comparison_expr
         | a_expr
         | "not" not_test
         ;


//-----------------------------------------------------------------------------
//  Statements
//-----------------------------------------------------------------------------
stmt : simple_stmt (";"! simple_stmt)* ";"!?
     | compound_stmt
     ;


//-----------------------------------------------------------------------------
//  Simple Statements
//-----------------------------------------------------------------------------

simple_stmt : expression_stmt
            | assignment_stmt
            | pass_stmt
            | print_stmt
            | return_stmt
            | break_stmt
            | continue_stmt
            ;

expression_stmt : expression_list
                ;

assignment_stmt : target_list "="! expression_list { $$ = make_assign($*); } 
                ;

target_list : "("! main_target_list ")"!
            | "["! main_target_list "]"!
            ;

// Needed to resolve some conflicts with target lists
// Is this still needed?
main_target_list : target (","! target)* ","!? 
                 ;

target : identifier                 /* RR conflict with atom. Resolve with GLR. */
       | attributeref               /* RR conflict with primary. Resolve with GLR. */
       | subscription               /* RR conflict with primary. Resolve with GLR. */
       | slicing                    /* RR conflict with primary. Resolve with GLR. */
       ;

pass_stmt : "pass"
          ;

print_stmt : "print"  expression_list 
                      { $$ = $^(PRINTLN, $^(EMPTY), $expression_list); }
           ;

return_stmt : "return" expression_list
            ;

break_stmt : "break"
           ;

continue_stmt : "continue"
              ;

//-----------------------------------------------------------------------------
//  Compound Statements
//-----------------------------------------------------------------------------
compound_stmt : if_stmt
              | while_stmt
              | for_stmt
              | funcdef
              | classdef
              ;

if_stmt : "if" expression ":" suite "\n"
        | "if" expression ":" suite elseif_stmt
        ;

elseif_stmt : else_stmt
            | "elif" expression ":" suite elseif_stmt
            ;

else_stmt : "else" expression ":" suite
          ;

while_stmt : "while" expression ":" suite else_stmt
           ;

for_stmt : "for" target_list "in" expression_list ":" suite else_stmt
         ;

suite : stmt_list 
      | '\n'! INDENT statement DEDENT
      ;

statement : stmt_list '\n'!
          | stmt_list '\n'! statement
          | compound_stmt
          ;

//-----------------------------------------------------------------------------
//  Function and class definitions
//-----------------------------------------------------------------------------

funcdef : "def" funcname "(" parameter_list ")" ":" suite
        ;

funcname : identifier
         ;

parameter_list : /* empty */
               | identifier parameter_list
               ;

// TODO: Should not end with a suite. Define classsuite.
classdef : "class" classname ":"! suite
         ;

classname : identifier
          ;

%%

bool debugParser;

/* Utilities */
//-----------------------------------------------------------------------------
//  Generalizable make functions
//-----------------------------------------------------------------------------

static AST_Ptr make_expr_id_expr(const List_Ptr& operands, int op) {
    return YYMAKE_TREE(op, 
                       operands->at(0), 
                       make_id(operands->at(1)),
                       operands->at(2));
}

static AST_Ptr make_expr_expr(const List_Ptr& operands, int op) {
    return YYMAKE_TREE(op, operands->at(0), operands->at(1));
}


//-----------------------------------------------------------------------------
//  Specific make functions that may use those above internally.
//  At least one of these per entry in the AST table in proj1 handout
//-----------------------------------------------------------------------------
static AST_Ptr make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE(UNOP, make_id(operands->at(0)), operands->at(1));
}

static AST_Ptr make_binop (const List_Ptr& operands)
{
    return make_expr_id_expr(operands, BINOP);
}

static AST_Ptr make_left_compare(const List_Ptr &operands) {
    return make_expr_id_expr(operands, LEFT_COMPARE);
}

static AST_Ptr make_compare(const List_Ptr &operands) {
    return make_expr_id_expr(operands, COMPARE);
}

static AST_Ptr make_id (const List_Ptr& operands) {
    return make_id(operands->at(0));
}
static AST_Ptr make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size(), 
                                      token->as_chars(), false);
    result->set_loc (token->loc ());
    return result;
}

static AST_Ptr make_id (const char *text, const char *loc) {
    AST_Ptr result = AST::make_token(ID, strlen(text), text, false);
    result->set_loc(loc);
    return result;
}

static AST_Ptr make_if_expr(const List_Ptr &operands) {
    return YYMAKE_TREE(IF_EXPR, operands->at(0),
                       operands->at(1), operands->at(2));

}

static AST_Ptr make_assign(const List_Ptr &operands) {
    return YYMAKE_TREE(ASSIGN, operands->at(0), operands->at(1));
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}

/* -------------- HELPER FUNCTIONS ------------- */
static void
check_identifier (const char* text)
{
  for (int i = 0; i < 14; i++ )
  {
    if ( invalid_keywords[i].compare(text) == 0 ) {
      error(yysource_location(), "Identifier is illegall keyword");
    }
  }
  for (int i = 0; i < 18; i++ )
  {
    if ( keywords[i].compare(text) == 0 ) {
      error(yysource_location(), "Identifier is a keyword");
    }
  }
}

static int
indent_size (const char* indent)
{
  int size = 0;
  for (int i = 0; indent[i] != '\0'; i++)
  {
    if (indent[i] == ' ')
    {
      size += 1;
    }
    else if (indent[i] == '\t')
    {
      size += 8 - (size % 8);
    }
    else
    {
      error(yysource_location(), "Indentation error");
    }
  }
  return size;
}

static int
indent (const char* indent)
{
  int indent_length = indent_size(indent);
  if (indent_length > current_indent_length)
  {
    indent_stack.push(indent_length - current_indent_length);
    current_indent_length = indent_length;
    return INDENT;
  }
  else if (indent_length < current_indent_length)
  {
    if (!indent_stack.empty())
    {
      current_indent_length -= indent_stack.top();
      indent_stack.pop();
    }
    else
    {
      error(yysource_location(), "Indentation error");
    }
    while (indent_length < current_indent_length)
    {
      yyqueue_token(DEDENT, 0, 0, "", 8);
      if (!indent_stack.empty())
      {
        current_indent_length -= indent_stack.top();
        indent_stack.pop();
      }
      else
      {
        error(yysource_location(), "Indentation error");
      }
    }
    
    if (current_indent_length == indent_length)
      error(yysource_location(), "Indentation error");
    else
      return DEDENT;
  }
  else
  {
    return -1;
  }
  error(yysource_location(), "Indentation error");
  return 0;
}
