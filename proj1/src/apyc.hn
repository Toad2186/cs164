/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors:
 * Toan Vuong
 * Eugene Huang
 * Dennis Rong
*/

%define semantic_tree_type "AST"

%{
  #include <string>
  #include <algorithm>
  #include "apyc.h"
  #include "ast.h"

  using namespace std;

  static AST_Ptr theTree;

/* Utilities */
//-----------------------------------------------------------------------------
//  Generalizable make functions
//-----------------------------------------------------------------------------

/*
 * Given a list of operands and OP, make a tree:
 * (OP, N, Expr(0), Id(1), Expr(2))
 * Where Expr(i) is the direct node from the list of operands
 * and Id(1) is the node returned by make_id of the first operand
*/
static AST_Ptr make_expr_id_expr(const List_Ptr &operands, int op); 

/*
 * Given a list of operands and OP, make a tree:
 * (OP, N, Expr(0), Expr(1))
 * Where Expr(i) is the direct node from the list of operands
*/
static AST_Ptr make_expr_expr(const List_Ptr &operands, int op);

//-----------------------------------------------------------------------------
//  Specific make functions that may use those above internally.
//  At least one of these per entry in the AST table in proj1 handout
//-----------------------------------------------------------------------------

/** Return a new unop node corresponding to OPERANDS, which is the list of
*  right-hand-side semantic values of a unop production (consisting of a
*  token for the operator, followed by the AST for the operand). */
static AST_Ptr make_unop (const List_Ptr& operands);

/** Return a new binop node corresponding to OPERANDS, which is the list of
*  right-hand-side semantic values of a binop production (consisting of an
*  AST for the first operand, a token for the operator, and an AST for the
*  second operand). */
static AST_Ptr make_binop(const List_Ptr &operands);

/*
 * Makes a left_compare node
*/
static AST_Ptr make_left_compare(const List_Ptr &operands);

/*
 * Makes  acompare node
*/
static AST_Ptr make_compare(const List_Ptr &operands);

/*
* Makes an id from the first operand in OPERANDS.
*/
static AST_Ptr make_id (const List_Ptr& operands);

/** Return a new ID node, where the text of the identifier is given by
*  TOKEN. */
static AST_Ptr make_id (AST_Ptr& token);

/*
 * Makes an id token from text
*/
static AST_Ptr make_id (const char *text, const char*loc);

/*
 * Makes an if_expr node.
 * Expects a list of three operands: condition, expr1, expr2
*/
static AST_Ptr make_if_expr(AST_Ptr &condition, AST_Ptr &expr1, AST_Ptr &expr2);

/*
 * Makes an assignment
*/
static AST_Ptr make_assign(const List_Ptr &operands);

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a consant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token ID

%token PRINTLN "@println"
%token EMPTY 
%token EXPR_LIST "@expr_list"
%token MODULE "@module"
%token BINOP "@binop"
%token UNOP "@unop"
%token INT_LITERAL "@int_literal"
%token DICT_DISPLAY "@dict_display"
%token COMPARE "@compare"
%token LEFT_COMPARE "@left_compare"
%token ASSIGN "@assign"
%token IF_EXPR "@if_expr"

%token STRING
%token STRING_LITERAL

/* Keywords */
%token AND "and"
%token BREAK "break"
%token CLASS "class"
%token CONTINUE "continue"
%token DEF "def"
%token ELIF "elif"
%token ELSE "else"
%token FOR "for"
%token FROM "from"
%token IF "if"
%token IN "in"
%token IS "is"
%token NOT "not"
%token OR "or"
%token PASS "pass"
%token PRINT "print"
%token RETURN "return"
%token WHILE "while"

%%

/************** LEXICAL RULES ********************/
/*
 * All Caps for clarity
 * No unicode, long ints, imaginary, float, or unallowed keywords
 */

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;

/*
 * Predefined: _ANY, _UPPER, _LOWER, _CONTROL, _EOL, _BOL
 */

// TEMPORARY
INDENT : "indent"
       ;
DEDENT : "dedent"
       ;

_BLANK : ' ' | '\t' ;

_DIGIT : '0' .. '9' ;
_NONZERODIGIT : '1' .. '9' ;
_HEXDIGIT : _DIGIT | 'a' .. 'f' | 'A' .. 'F' ;
_OCTDIGIT : '0' .. '7' ;

_DECIMALINTEGER : _NONZERODIGIT _DIGIT* | "0" ;
_OCTINTEGER : "0" _OCTDIGIT+ ;
_HEXINTEGER: "0" ( "x" | "X" ) _HEXDIGIT+ ;
_INTEGER : _DECIMALINTEGER | _OCTINTEGER | _HEXINTEGER ;
_EXPONENT : ( "e" | "E" ) ( "+" | "-")? _DIGIT+ ;

_LOWER : 'a' .. 'z' ;
_UPPER : 'A' .. 'Z' ;
_LETTER : _UPPER | _LOWER ;

_RAWSTRINGPREFIX : 'r' | 'R' ;
_RAWESCAPESEQ : '\\' _ANY ;
_ESCAPESEQ : _RAWESCAPESEQ | ( '\\' _OCTDIGIT _OCTDIGIT? _OCTDIGIT? ) ;

/* Careful. Horn rules can only do set subtraction on its own lexical rule */
_NO_SINGLEQUOTE : _ANY - ('\'' | '\n') ;
_NO_DOUBLEQUOTE : _ANY - ('"' | '\n') ;
_NO_SLASH : _ANY - ('\\' | '\n') ;

_SHORTSTRINGITEM1 : _NO_SINGLEQUOTE | _ESCAPESEQ ;
_SHORTSTRINGITEM2 : _NO_DOUBLEQUOTE | _ESCAPESEQ ;
_LONGSTRINGITEM : _NO_SLASH | _ESCAPESEQ ;

_RAWSHORTSTRINGITEM1 : _NO_SINGLEQUOTE | _RAWESCAPESEQ ;
_RAWSHORTSTRINGITEM2 : _NO_DOUBLEQUOTE | _RAWESCAPESEQ ;
_RAWLONGSTRINGITEM : _NO_SLASH | _RAWESCAPESEQ ;

_SHORTSTRING : '\'' _SHORTSTRINGITEM1* '\''
    | '"' _SHORTSTRINGITEM2* '"'
    ;
_RAWSHORTSTRING : '\'' _RAWSHORTSTRINGITEM1* '\''
    | '"' _RAWSHORTSTRINGITEM2* '"'
    ;

/* TODO: Helper function find 'shortest sequence of longitems' */
_LONGSTRING : "'''" ( _LONGSTRINGITEM* ("'" | "''")? )* "'''"
    | "\"\"\"" ( _LONGSTRINGITEM* ("\"" | "\"\"")? )* "\"\"\""
    ;
_RAWLONGSTRING : "'''" ( _RAWLONGSTRINGITEM* ("'" | "''")? )* "'''"
    | "\"\"\"" ( _RAWLONGSTRINGITEM* ("\"" | "\"\"")? )* "\"\"\""
    ;

/* TODO: fix */
/* Unsupported Keywords. Error */
/* *: ( "as" | "assert" | "del" | "except" | "exec" | "finally" | "future" | "global"
 *   | "import" | "lambda" | "raise" | "try" | "with" | "yield" ) ;
 */

/* _NO_NEWLINE : _ANY - '\n' ; 
 * _COMMENT : '#' _NO_NEWLINE* ;
 * BLANK_LINE : _BLANK* _EOL
 *   | _BLANK* _COMMENT
 *   ;
 */

/* TODO: Need to exclude keywords. */
IDENTIFIER : ( _LETTER | "_" ) ( _LETTER | _DIGIT | "_" )* ;

/* RULES FOR AST */
INT_LITERAL : _INTEGER ;
_STRINGLITERALPIECE : ( _SHORTSTRING | _LONGSTRING )
    | _RAWSTRINGPREFIX ( _RAWSHORTSTRING | _RAWLONGSTRING )
    ;
STRING_LITERAL : _STRINGLITERALPIECE+ ;

RAWSTRING : _RAWSTRINGPREFIX (_RAWSHORTSTRING | _RAWLONGSTRING) ;


/**************** GRAMMAR RULES ********************/

/*
 * Start program
*/
program : stmt_list   { theTree = $^(MODULE, $*); $$ = NULL; }
        ;

/*
 * Main statements and expressions
*/
stmt_list : stmt stmt_list
          | /* empty */
          ;

expression_list : expression
                | expression (","! expression)* { $$ = $^(EXPR_LIST, $*); }
                | /* empty */                   { $$ = $^(EXPR_LIST); }
                ;

expression : conditional_expr 
           ;

enclosure : parenth_form
          | list_display
          | dict_display
          | string_conversion
          ;

string_conversion : '`' expression_list '`'
                  ;

parenth_form : "(" expression_list ")"
             ;

/*
 * Basic units
*/
identifier : IDENTIFIER
           ;
atom : identifier
     | literal
     | enclosure
     ;

primary : atom                       
        | attributeref
        | subscription
        ;

literal : STRING_LITERAL
        | INT_LITERAL
        ;


attributeref : primary "." identifier
             ;

subscription : primary "[" expression_list "]"
             ;


//-----------------------------------------------------------------------------
//  Lists
//-----------------------------------------------------------------------------
list_display : "[" expression_list "]"
             ;
//-----------------------------------------------------------------------------
//  Dictionaries
//-----------------------------------------------------------------------------
dict_display : "{" key_datum_list "}"
             | "{" "}"
             ;

key_datum_list : key_datum
               | key_datum "," key_datum_list ","?
               ;

key_datum : expression ":" expression
          ;

//-----------------------------------------------------------------------------
//  Slicing
//-----------------------------------------------------------------------------
slicing : simple_slicing
        ;

simple_slicing : primary "[" short_slice "]"
               ;

short_slice : lower_bound ":" upper_bound
            ;

lower_bound : expression
            | /* empty */
            ;

upper_bound : lower_bound
            ;

/*
 * Primitive operators + - * ** / //
*/
power : primary                     
      | primary "**" u_expr         { $$ = make_binop($*); }
      ;

u_expr : power                     
       | "-" u_expr                 { $$ = make_unop($*); }
       | "+" u_expr                 { $$ = make_unop($*); }
       ;

m_expr : u_expr                    
       | m_expr "*" u_expr          { $$ = make_binop($*); }
       | m_expr "//" u_expr         { $$ = make_binop($*); }
       | m_expr "/" u_expr          { $$ = make_binop($*); }
       | m_expr "%" u_expr          { $$ = make_binop($*); }
       ;

a_expr : m_expr                 
       | a_expr "+" m_expr          { $$ = make_binop($*); }
       | a_expr "-" m_expr          { $$ = make_binop($*); }
       ;

/*
 * Comparisons. Need to differentiate between compare and left_compare
*/
comparison_expr : a_expr comp_operator a_expr                   { $$ = make_compare($*); }
                | a_expr comp_operator comparison_expr          { $$ = make_left_compare($*); }
                ;

comp_operator : "<"
              | ">"
              | "=="
              | ">="
              | "<="
              | "!="
              | "is"
// TODO: Not pass in a constant isnot and notin. 
              | L="is not"              { $$ = make_id("isnot", $L.loc()); } 
              | "in"
              | L="not in"              { $$ = make_id("notin", $L.loc()); }
              ;

/*
 * Boolean operators
*/
conditional_expr : or_test
                 | cond=or_test "if" expr1=or_test "else" expr2=expression 
                    { $$ = make_if_expr($cond,
                                        $expr1,
                                        $expr2);
                    }
                 ;

or_test : and_test
        | or_test "or" and_test
        ;
and_test : not_test
         | and_test "and" not_test
         ;
not_test : comparison_expr
         | a_expr
         | "not" not_test
         ;


//-----------------------------------------------------------------------------
//  Statements
//-----------------------------------------------------------------------------
stmt : simple_stmt '\n'!
     | compound_stmt
     ;


//-----------------------------------------------------------------------------
//  Simple Statements
//-----------------------------------------------------------------------------

simple_stmt : expression_stmt
            | assignment_stmt
            | pass_stmt
            | print_stmt
            | return_stmt
            | break_stmt
            | continue_stmt
            ;

expression_stmt : expression_list
                ;

assignment_stmt : target_list "="! expression_list { $$ = make_assign($*); } 
                ;

// No nested targets as in S8 of proj1 handout
target_list : target
            ;

target : identifier 
       | "(" target_list ")"
       | "[" target_list "]"
       | attributeref
       | subscription
       | slicing
       ;

pass_stmt : "pass"
          ;

print_stmt : "print"  expression_list 
                      { $$ = $^(PRINTLN, $^(EMPTY), $expression_list); }
           ;

return_stmt : "return" expression_list
            ;

break_stmt : "break"
           ;

continue_stmt : "continue"
              ;

//-----------------------------------------------------------------------------
//  Compound Statements
//-----------------------------------------------------------------------------
compound_stmt : if_stmt
              | while_stmt
              | for_stmt
              | funcdef
              | classdef
              ;

if_stmt : "if" expression ":" suite elseif_stmt 
        ;

elseif_stmt : else_stmt
            | "elif" expression ":" suite elseif_stmt
            ;

else_stmt : "else" expression ":" suite
          | /* empty */
          ;

while_stmt : "while" expression ":" suite else_stmt
           ;

for_stmt : "for" target_list "in" expression_list ":" suite else_stmt
         ;

suite : stmt_list '\n'!
      | '\n'! INDENT statement DEDENT
      ;

statement : stmt_list '\n'!
          | stmt_list '\n'! statement
          | compound_stmt
          ;

//-----------------------------------------------------------------------------
//  Function and class definitions
//-----------------------------------------------------------------------------

funcdef : "def" funcname "(" parameter_list ")" ":" suite
        ;

funcname : identifier
         ;

parameter_list : /* empty */
               | identifier parameter_list
               ;

classdef : "class" classname ":"! suite
         ;

classname : identifier
          ;



%%

bool debugParser;

/* Utilities */
//-----------------------------------------------------------------------------
//  Generalizable make functions
//-----------------------------------------------------------------------------

static AST_Ptr make_expr_id_expr(const List_Ptr& operands, int op) {
    return YYMAKE_TREE(op, 
                       operands->at(0), 
                       make_id(operands->at(1)),
                       operands->at(2));
}

static AST_Ptr make_expr_expr(const List_Ptr& operands, int op) {
    return YYMAKE_TREE(op, operands->at(0), operands->at(1));
}


//-----------------------------------------------------------------------------
//  Specific make functions that may use those above internally.
//  At least one of these per entry in the AST table in proj1 handout
//-----------------------------------------------------------------------------
static AST_Ptr make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE(UNOP, make_id(operands->at(0)), operands->at(1));
}

static AST_Ptr make_binop (const List_Ptr& operands)
{
    return make_expr_id_expr(operands, BINOP);
}

static AST_Ptr make_left_compare(const List_Ptr &operands) {
    return make_expr_id_expr(operands, LEFT_COMPARE);
}

static AST_Ptr make_compare(const List_Ptr &operands) {
    return make_expr_id_expr(operands, COMPARE);
}

static AST_Ptr make_id (const List_Ptr& operands) {
    return make_id(operands->at(0));
}
static AST_Ptr make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size(), 
                                      token->as_chars(), false);
    result->set_loc (token->loc ());
    return result;
}

static AST_Ptr make_id (const char *text, const char *loc) {
    AST_Ptr result = AST::make_token(ID, strlen(text), text, false);
    result->set_loc(loc);
    return result;
}

static AST_Ptr make_if_expr(AST_Ptr &condition, AST_Ptr &expr1, AST_Ptr &expr2) {
    return YYMAKE_TREE(IF_EXPR, operands->at(0),
                       operands->at(1), operands->at(2));

}

static AST_Ptr make_assign(const List_Ptr &operands) {
    return YYMAKE_TREE(ASSIGN, operands->at(0), operands->at(1));
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}

/* -------------- HELPER FUNCTIONS ------------- */
/*
static void
check_identifier (const char* text)
{
  if ((text == "and") || (text == "break"))
}
*/
